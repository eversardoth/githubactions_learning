name: RA Tag and Release
description: Tags and publishes pre and stable releases
inputs:
  prerelease:
    description: Indicator of whether or not is a prerelease
    required: false
  files:
    description: String with glob patterns of files that should be uploaded to the release
    required: false

runs:
  using: 'composite'
  steps:
    - name: Tag generation
      id: tag_generation
      uses: paulhatch/semantic-version@v5.0.3
      with:
        tag_prefix: "v"
        major_pattern: (MAJOR)
        minor_pattern: (MINOR)
        version_format: v${major}.${minor}.${patch}
    - name: Tag and Publish release
      id: tag_release
      env:
        tag_name: ${{ steps.tag_generation.outputs.version_tag }}
        target_commitish: ${{ github.sha }}
        prerelease: ${{ inputs.prerelease }}
        files: ${{ inputs.files }}
      uses: actions/github-script@v6
      with:
        retries: 3
        script: |
            async function calculateLastPrerelease(tag_name) {

                try {
                    for await (const response of github.paginate.iterator(
                        github.rest.repos.listTags,
                        {
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                        }
                    )) {
                        const regex = RegExp(`^${tag_name}-[0-9]+$`);
                        const latest_tag = response.data.find((tag) => { return regex.test(tag.name) });
                        if (latest_tag) {
                            return Number(latest_tag.name.split('-').pop());
                        }
                    }
                    return 0;

                } catch (error) {
                    core.info("Unexpected error fetching exisitng releases and generating prerelease suffix");
                    throw error;
                }

            }

            async function createRelease(owner, repo, tag_name, last_prerelease, target_commitish, prerelease, max_suffix_increase = 3) {

                if (max_suffix_increase <= 0) {
                    core.info("Too many suffix increase retries. Aborting...");
                    throw new Error("Too many suffix increases.");
                }

                try {

                    const release = await github.rest.repos.createRelease({
                        owner: owner,
                        repo: repo,
                        tag_name: prerelease ? `${tag_name}-${last_prerelease + 1}` : tag_name,
                        target_commitish: target_commitish,
                        prerelease: prerelease,
                    });

                    return release;

                } catch (error) {

                    if (error.status === 422 && error.response.data.errors?.find((error) => error.resource === "Release" && error.code === "already_exists" && error.field === "tag_name")) {
                        core.warning("The generated prerelease suffix already exists, retrying with a higher suffix");
                        return createRelease(owner, repo, tag_name, last_prerelease + 1, target_commitish, prerelease, max_suffix_increase - 1);
                    }

                    core.info("There has been an issue tagging and publishing the release");
                    throw error;
                }


            }

            async function uploadAssets(release_id){

                // Search glob matching files and try to upload them

                const globber = await glob.create(process.env.files);

                const path = require('path');

                const fs = require('fs');

                try {
                    for await (const file of globber.globGenerator()) {

                        const name = path.basename(file);

                        const file_type = "application/octet-stream";

                        const data = fs.readFileSync(file);

                        await github.rest.repos.uploadReleaseAsset({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            release_id: release_id,
                            name: name,
                            data: data,
                            headers: {
                                "content-type": file_type
                            }
                        });
                    }

                } catch (error) {

                    core.info('There has been an issue uploading the provided glob patterned files');
                    throw error;

                }
                
            }

            try {

                const prerelease_validation = process.env.prerelease.toUpperCase();

                // Check supported release types
                if (prerelease_validation !== 'TRUE' && prerelease_validation !== 'FALSE') {
                    throw new Error("Invalid prerelease input (valid options: 'true', 'false', 'TRUE', 'FALSE'")
                } else {
                    
                }

                const prerelease = prerelease_validation === 'TRUE';
                core.info(`This action was set to publish a ${prerelease ? 'prerelease' : 'release'}`)


                const tag_name = process.env.tag_name;

                // Calculate pre-release suffix based on retrieved list from API
                let last_prerelease = 0;

                if (prerelease) {
                    last_prerelease = await calculateLastPrerelease(tag_name);
                }

                //Create release and retrying 3 times with higher prerelease suffix if it already exists
                const release = await createRelease(context.repo.owner, context.repo.repo, tag_name, last_prerelease, process.env.target_commitish, prerelease, 3);

                //Upload release assets
                await uploadAssets(release.data.id);

            } catch (error) {
                core.setFailed(error);
            }
    - name: Only publish
      if: ${{ false }}
      uses: softprops/action-gh-release@v0.1.15
      with:
        tag_name: ${steps.tag_release.outputs.tag_name}
        files: ${{ inputs.files }}
        prerelease: ${{inputs.prerelease }}